C0 C0 FF EE       # magic number
00 13             # version 9, arch = 1 (64 bits)

00 06             # int pool count
# int pool
00 00 00 FF
00 00 00 FF
00 00 00 FF
00 00 00 FF
7F FF FF FF
80 00 00 00

01 DA             # string pool total size
# string pool
49 6E 70 75 74 20 69 6D 61 67 65 20 66 69 6C 65 3A 20 20 00  # "Input image file:  "
4F 75 74 70 75 74 20 69 6D 61 67 65 20 66 69 6C 65 3A 20 00  # "Output image file: "
42 6C 75 72 20 6D 61 73 6B 20 66 69 6C 65 3A 20 00  # "Blur mask file: "
00  # ""
43 6F 75 6C 64 20 6E 6F 74 20 6C 6F 61 64 20 73 6F 75 72 63 65 20 69 6D 61 67 65 00  # "Could not load source image"
4C 6F 61 64 65 64 20 69 6D 61 67 65 2E 20 20 44 69 6D 65 6E 73 69 6F 6E 73 20 61 72 65 20 00  # "Loaded image.  Dimensions are "
20 62 79 20 00  # " by "
2E 00  # "."
49 6E 76 61 6C 69 64 20 62 6C 75 72 20 6D 61 73 6B 20 73 69 7A 65 00  # "Invalid blur mask size"
49 6E 76 61 6C 69 64 20 62 6C 75 72 20 6D 61 73 6B 20 73 69 7A 65 00  # "Invalid blur mask size"
00  # ""
4C 69 6E 65 20 00  # "Line "
20 68 61 73 20 69 6E 76 61 6C 69 64 20 77 65 69 67 68 74 00  # " has invalid weight"
4E 6F 74 20 65 6E 6F 75 67 68 20 77 65 69 67 68 74 73 20 69 6E 20 6D 61 73 6B 20 66 69 6C 65 00  # "Not enough weights in mask file"
57 61 72 6E 69 6E 67 3A 20 69 67 6E 6F 72 69 6E 67 20 65 78 74 72 61 20 76 61 6C 75 65 73 20 69 6E 20 6D 61 73 6B 20 66 69 6C 65 21 0A 00  # "Warning: ignoring extra values in mask file!\n"
4F 72 69 67 69 6E 20 6F 66 20 6D 61 73 6B 20 68 61 73 20 76 61 6C 75 65 20 30 00  # "Origin of mask has value 0"
52 75 6E 6E 69 6E 67 20 62 6C 75 72 2E 2E 2E 00  # "Running blur..."
64 6F 6E 65 2E 00  # "done."
53 61 76 69 6E 67 20 6F 75 74 70 75 74 2E 2E 2E 00  # "Saving output..."
64 6F 6E 65 2E 00  # "done."
2E 70 6E 67 00  # ".png"
49 6E 70 75 74 20 66 69 6C 65 20 64 6F 65 73 20 6E 6F 74 20 65 6E 64 20 77 69 74 68 20 2E 70 6E 67 00  # "Input file does not end with .png"
5F 00  # "_"
2E 70 6E 67 00  # ".png"
2D 6F 00  # "-o"
2D 69 00  # "-i"
2D 6D 00  # "-m"
00  # ""
00  # ""
55 73 61 67 65 3A 20 62 6C 75 72 20 2D 69 20 3C 69 6E 70 75 74 20 69 6D 61 67 65 3E 20 2D 6D 20 3C 62 6C 75 72 20 6D 61 73 6B 3E 20 5B 2D 6F 20 3C 6F 75 74 70 75 74 20 69 6D 61 67 65 3E 5D 00  # "Usage: blur -i <input image> -m <blur mask> [-o <output image>]"
00  # ""
62 6C 75 72 00  # "blur"

00 1A             # function count
# function_pool

#<main>
00 00             # number of arguments = 0
00 14             # number of local variables = 20
00 84             # code length = 132 bytes
BB 08    # new 8           # alloc(string)
36 00    # vstore 0        # output = alloc(string);
BB 08    # new 8           # alloc(string)
36 01    # vstore 1        # input = alloc(string);
BB 08    # new 8           # alloc(string)
36 02    # vstore 2        # mask = alloc(string);
14 01 89 # aldc 393        # s[393] = "-o"
15 00    # vload 0         # output
B7 00 15 # invokenative 21 # args_string("-o", output)
57       # pop             # (ignore result)
14 01 8C # aldc 396        # s[396] = "-i"
15 01    # vload 1         # input
B7 00 15 # invokenative 21 # args_string("-i", input)
57       # pop             # (ignore result)
14 01 8F # aldc 399        # s[399] = "-m"
15 02    # vload 2         # mask
B7 00 15 # invokenative 21 # args_string("-m", mask)
57       # pop             # (ignore result)
B7 00 16 # invokenative 22 # args_parse()
57       # pop             # (ignore result)
14 01 92 # aldc 402        # s[402] = ""
15 01    # vload 1         # input
2F       # amload          # *(input)
B7 00 12 # invokenative 18 # string_equal("", *(input))
10 01    # bipush 1        # true
9F 00 17 # if_cmpeq +23    # if (string_equal("", *(input)) == true) goto <94:then>
A7 00 03 # goto +3         # goto <97:or>
# <97:or>
14 01 93 # aldc 403        # s[403] = ""
15 02    # vload 2         # mask
2F       # amload          # *(mask)
B7 00 12 # invokenative 18 # string_equal("", *(mask))
10 01    # bipush 1        # true
9F 00 06 # if_cmpeq +6     # if (string_equal("", *(mask)) == true) goto <94:then>
A7 00 0A # goto +10        # goto <95:else>
# <94:then>
14 01 94 # aldc 404        # s[404] = "Usage: blur -i <input image> -m <blur mask> [-o <output image>]"
BF       # athrow          # error "Usage: blur -i <input image> -m <blur mask> [-o <output image>]"
A7 00 03 # goto +3         # goto <96:endif>
# <95:else>
# <96:endif>
14 01 D4 # aldc 468        # s[468] = ""
15 00    # vload 0         # output
2F       # amload          # *(output)
B7 00 12 # invokenative 18 # string_equal("", *(output))
10 01    # bipush 1        # true
9F 00 06 # if_cmpeq +6     # if (string_equal("", *(output)) == true) goto <98:then>
A7 00 12 # goto +18        # goto <99:else>
# <98:then>
15 00    # vload 0         # output
15 01    # vload 1         # input
2F       # amload          # *(input)
14 01 D5 # aldc 469        # s[469] = "blur"
B8 00 19 # invokestatic 25 # default_output(*(input), "blur")
4F       # amstore         # *(output) = default_output(*(input), "blur");
A7 00 03 # goto +3         # goto <100:endif>
# <99:else>
# <100:endif>
15 01    # vload 1         # input
2F       # amload          # *(input)
15 00    # vload 0         # output
2F       # amload          # *(output)
15 02    # vload 2         # mask
2F       # amload          # *(mask)
B8 00 18 # invokestatic 24 # blur_main(*(input), *(output), *(mask))
57       # pop             # (ignore result)
10 00    # bipush 0        # 0
B0       # return          # 


#<get_red>
00 01             # number of arguments = 1
00 01             # number of local variables = 1
00 0A             # code length = 10 bytes
15 00    # vload 0         # p
10 10    # bipush 16       # 16
7A       # ishr            # (p >> 16)
13 00 00 # ildc 0          # c[0] = 255
7E       # iand            # ((p >> 16) & 255)
B0       # return          # 


#<get_green>
00 01             # number of arguments = 1
00 01             # number of local variables = 1
00 0A             # code length = 10 bytes
15 00    # vload 0         # p
10 08    # bipush 8        # 8
7A       # ishr            # (p >> 8)
13 00 01 # ildc 1          # c[1] = 255
7E       # iand            # ((p >> 8) & 255)
B0       # return          # 


#<get_blue>
00 01             # number of arguments = 1
00 01             # number of local variables = 1
00 07             # code length = 7 bytes
15 00    # vload 0         # p
13 00 02 # ildc 2          # c[2] = 255
7E       # iand            # (p & 255)
B0       # return          # 


#<get_alpha>
00 01             # number of arguments = 1
00 01             # number of local variables = 1
00 0A             # code length = 10 bytes
15 00    # vload 0         # p
10 18    # bipush 24       # 24
7A       # ishr            # (p >> 24)
13 00 03 # ildc 3          # c[3] = 255
7E       # iand            # ((p >> 24) & 255)
B0       # return          # 


#<make_pixel>
00 04             # number of arguments = 4
00 04             # number of local variables = 4
00 15             # code length = 21 bytes
15 00    # vload 0         # alpha
10 18    # bipush 24       # 24
78       # ishl            # (alpha << 24)
15 01    # vload 1         # red
10 10    # bipush 16       # 16
78       # ishl            # (red << 16)
60       # iadd            # ((alpha << 24) + (red << 16))
15 02    # vload 2         # green
10 08    # bipush 8        # 8
78       # ishl            # (green << 8)
60       # iadd            # (((alpha << 24) + (red << 16)) + (green << 8))
15 03    # vload 3         # blue
60       # iadd            # ((((alpha << 24) + (red << 16)) + (green << 8)) + blue)
B0       # return          # 


#<int_size>
00 00             # number of arguments = 0
00 04             # number of local variables = 4
00 03             # code length = 3 bytes
10 04    # bipush 4        # 4
B0       # return          # 


#<int_max>
00 00             # number of arguments = 0
00 04             # number of local variables = 4
00 04             # code length = 4 bytes
13 00 04 # ildc 4          # c[4] = 2147483647
B0       # return          # 


#<int_min>
00 00             # number of arguments = 0
00 04             # number of local variables = 4
00 04             # code length = 4 bytes
13 00 05 # ildc 5          # c[5] = -2147483648
B0       # return          # 


#<abs>
00 01             # number of arguments = 1
00 04             # number of local variables = 4
00 15             # code length = 21 bytes
15 00    # vload 0         # x
10 00    # bipush 0        # 0
A1 00 06 # if_icmplt +6    # if (x < 0) goto <06:cond_true>
A7 00 0B # goto +11        # goto <07:cond_false>
# <06:cond_true>
10 00    # bipush 0        # 
15 00    # vload 0         # x
64       # isub            # -(x)
A7 00 05 # goto +5         # goto <08:cond_end>
# <07:cond_false>
15 00    # vload 0         # x
# <08:cond_end>
B0       # return          # 


#<max>
00 02             # number of arguments = 2
00 04             # number of local variables = 4
00 12             # code length = 18 bytes
15 00    # vload 0         # x
15 01    # vload 1         # y
A3 00 06 # if_icmpgt +6    # if (x > y) goto <00:cond_true>
A7 00 08 # goto +8         # goto <01:cond_false>
# <00:cond_true>
15 00    # vload 0         # x
A7 00 05 # goto +5         # goto <02:cond_end>
# <01:cond_false>
15 01    # vload 1         # y
# <02:cond_end>
B0       # return          # 


#<min>
00 02             # number of arguments = 2
00 04             # number of local variables = 4
00 12             # code length = 18 bytes
15 00    # vload 0         # x
15 01    # vload 1         # y
A3 00 06 # if_icmpgt +6    # if (x > y) goto <03:cond_true>
A7 00 08 # goto +8         # goto <04:cond_false>
# <03:cond_true>
15 01    # vload 1         # y
A7 00 05 # goto +5         # goto <05:cond_end>
# <04:cond_false>
15 00    # vload 0         # x
# <05:cond_end>
B0       # return          # 


#<int2hex>
00 01             # number of arguments = 1
00 04             # number of local variables = 4
00 52             # code length = 82 bytes
10 02    # bipush 2        # 2
B8 00 06 # invokestatic 6  # int_size()
68       # imul            # (2 * int_size())
36 01    # vstore 1        # digits = (2 * int_size());
15 01    # vload 1         # digits
10 01    # bipush 1        # 1
60       # iadd            # (digits + 1)
BC 01    # newarray 1      # alloc_array(char, (digits + 1))
36 02    # vstore 2        # s = alloc_array(char, (digits + 1));
15 02    # vload 2         # s
15 01    # vload 1         # digits
63       # aadds           # &s[digits]
10 00    # bipush 0        # '\000'
55       # cmstore         # s[digits] = '\0';
10 00    # bipush 0        # 0
36 03    # vstore 3        # i = 0;
# <17:loop>
15 03    # vload 3         # i
15 01    # vload 1         # digits
A1 00 06 # if_icmplt +6    # if (i < digits) goto <18:body>
A7 00 28 # goto +40        # goto <19:exit>
# <18:body>
15 02    # vload 2         # s
15 01    # vload 1         # digits
15 03    # vload 3         # i
64       # isub            # (digits - i)
10 01    # bipush 1        # 1
64       # isub            # ((digits - i) - 1)
63       # aadds           # &s[((digits - i) - 1)]
15 00    # vload 0         # x
10 0F    # bipush 15       # 15
7E       # iand            # (x & 15)
B8 00 0D # invokestatic 13 # hexdig2char((x & 15))
55       # cmstore         # s[((digits - i) - 1)] = hexdig2char((x & 15));
15 00    # vload 0         # x
10 04    # bipush 4        # 4
7A       # ishr            # (x >> 4)
36 00    # vstore 0        # x = (x >> 4);
15 03    # vload 3         # i
10 01    # bipush 1        # 1
60       # iadd            # 
36 03    # vstore 3        # i += 1;
A7 FF D4 # goto -44        # goto <17:loop>
# <19:exit>
15 02    # vload 2         # s
B7 00 02 # invokenative 2  # string_from_chararray(s)
B0       # return          # 


#<hexdig2char>
00 01             # number of arguments = 1
00 04             # number of local variables = 4
00 4C             # code length = 76 bytes
10 00    # bipush 0        # 0
15 00    # vload 0         # d
A4 00 06 # if_icmple +6    # if (0 <= d) goto <12:and>
A7 00 1C # goto +28        # goto <10:else>
# <12:and>
15 00    # vload 0         # d
10 0A    # bipush 10       # 10
A1 00 06 # if_icmplt +6    # if (d < 10) goto <09:then>
A7 00 12 # goto +18        # goto <10:else>
# <09:then>
10 30    # bipush 48       # '0'
B7 00 01 # invokenative 1  # char_ord('0')
15 00    # vload 0         # d
60       # iadd            # (char_ord('0') + d)
B7 00 00 # invokenative 0  # char_chr((char_ord('0') + d))
B0       # return          # 
A7 00 2C # goto +44        # goto <11:endif>
# <10:else>
10 0A    # bipush 10       # 10
15 00    # vload 0         # d
A4 00 06 # if_icmple +6    # if (10 <= d) goto <16:and>
A7 00 1F # goto +31        # goto <14:else>
# <16:and>
15 00    # vload 0         # d
10 10    # bipush 16       # 16
A1 00 06 # if_icmplt +6    # if (d < 16) goto <13:then>
A7 00 15 # goto +21        # goto <14:else>
# <13:then>
10 41    # bipush 65       # 'A'
B7 00 01 # invokenative 1  # char_ord('A')
15 00    # vload 0         # d
10 0A    # bipush 10       # 10
64       # isub            # (d - 10)
60       # iadd            # (char_ord('A') + (d - 10))
B7 00 00 # invokenative 0  # char_chr((char_ord('A') + (d - 10)))
B0       # return          # 
A7 00 06 # goto +6         # goto <15:endif>
# <14:else>
10 3F    # bipush 63       # '\?'
B0       # return          # 
# <15:endif>
# <11:endif>


#<is_valid_imagesize>
00 02             # number of arguments = 2
00 04             # number of local variables = 4
00 2F             # code length = 47 bytes
15 00    # vload 0         # width
10 00    # bipush 0        # 0
A3 00 06 # if_icmpgt +6    # if (width > 0) goto <23:and>
A7 00 25 # goto +37        # goto <21:cond_false>
# <23:and>
15 01    # vload 1         # height
10 00    # bipush 0        # 0
A3 00 06 # if_icmpgt +6    # if (height > 0) goto <20:cond_true>
A7 00 1B # goto +27        # goto <21:cond_false>
# <20:cond_true>
15 00    # vload 0         # width
B8 00 07 # invokestatic 7  # int_max()
15 01    # vload 1         # height
6C       # idiv            # (int_max() / height)
A4 00 06 # if_icmple +6    # if (width <= (int_max() / height)) goto <24:cond_true>
A7 00 08 # goto +8         # goto <25:cond_false>
# <24:cond_true>
10 01    # bipush 1        # true
A7 00 05 # goto +5         # goto <26:cond_end>
# <25:cond_false>
10 00    # bipush 0        # false
# <26:cond_end>
A7 00 05 # goto +5         # goto <22:cond_end>
# <21:cond_false>
10 00    # bipush 0        # false
# <22:cond_end>
B0       # return          # 


#<get_row>
00 03             # number of arguments = 3
00 04             # number of local variables = 4
00 06             # code length = 6 bytes
15 00    # vload 0         # index
15 01    # vload 1         # width
6C       # idiv            # (index / width)
B0       # return          # 


#<get_column>
00 03             # number of arguments = 3
00 04             # number of local variables = 4
00 06             # code length = 6 bytes
15 00    # vload 0         # index
15 01    # vload 1         # width
70       # irem            # (index % width)
B0       # return          # 


#<is_valid_pixel>
00 04             # number of arguments = 4
00 04             # number of local variables = 4
00 31             # code length = 49 bytes
15 00    # vload 0         # row
10 00    # bipush 0        # 0
A2 00 06 # if_icmpge +6    # if (row >= 0) goto <32:and>
A7 00 27 # goto +39        # goto <28:else>
# <32:and>
15 00    # vload 0         # row
15 03    # vload 3         # height
A1 00 06 # if_icmplt +6    # if (row < height) goto <31:and>
A7 00 1D # goto +29        # goto <28:else>
# <31:and>
15 01    # vload 1         # col
10 00    # bipush 0        # 0
A2 00 06 # if_icmpge +6    # if (col >= 0) goto <30:and>
A7 00 13 # goto +19        # goto <28:else>
# <30:and>
15 01    # vload 1         # col
15 02    # vload 2         # width
A1 00 06 # if_icmplt +6    # if (col < width) goto <27:then>
A7 00 09 # goto +9         # goto <28:else>
# <27:then>
10 01    # bipush 1        # true
B0       # return          # 
A7 00 06 # goto +6         # goto <29:endif>
# <28:else>
10 00    # bipush 0        # false
B0       # return          # 
# <29:endif>


#<get_index>
00 04             # number of arguments = 4
00 04             # number of local variables = 4
00 09             # code length = 9 bytes
15 00    # vload 0         # row
15 02    # vload 2         # width
68       # imul            # (row * width)
15 01    # vload 1         # col
60       # iadd            # ((row * width) + col)
B0       # return          # 


#<blur_each>
00 06             # number of arguments = 6
00 14             # number of local variables = 20
01 1E             # code length = 286 bytes
15 05    # vload 5         # maskwidth
10 02    # bipush 2        # 2
6C       # idiv            # (maskwidth / 2)
36 06    # vstore 6        # added = (maskwidth / 2);
15 06    # vload 6         # added
15 06    # vload 6         # added
15 05    # vload 5         # maskwidth
15 05    # vload 5         # maskwidth
B8 00 12 # invokestatic 18 # get_index(added, added, maskwidth, maskwidth)
36 07    # vstore 7        # origin = get_index(added, added, maskwidth, maskwidth);
15 00    # vload 0         # index
15 02    # vload 2         # width
15 03    # vload 3         # height
B8 00 0F # invokestatic 15 # get_row(index, width, height)
36 08    # vstore 8        # row = get_row(index, width, height);
15 00    # vload 0         # index
15 02    # vload 2         # width
15 03    # vload 3         # height
B8 00 10 # invokestatic 16 # get_column(index, width, height)
36 09    # vstore 9        # col = get_column(index, width, height);
15 08    # vload 8         # row
15 06    # vload 6         # added
64       # isub            # (row - added)
36 0A    # vstore 10       # mask_first_row = (row - added);
15 09    # vload 9         # col
15 06    # vload 6         # added
64       # isub            # (col - added)
36 0B    # vstore 11       # mask_first_col = (col - added);
10 00    # bipush 0        # 0
36 0C    # vstore 12       # sum_red = 0;
10 00    # bipush 0        # 0
36 0D    # vstore 13       # sum_green = 0;
10 00    # bipush 0        # 0
36 0E    # vstore 14       # sum_blue = 0;
10 00    # bipush 0        # 0
36 0F    # vstore 15       # weight = 0;
10 00    # bipush 0        # 0
36 12    # vstore 18       # i = 0;
# <36:loop>
15 12    # vload 18        # i
15 05    # vload 5         # maskwidth
A1 00 06 # if_icmplt +6    # if (i < maskwidth) goto <37:body>
A7 00 AB # goto +171       # goto <38:exit>
# <37:body>
10 00    # bipush 0        # 0
36 13    # vstore 19       # j = 0;
# <39:loop>
15 13    # vload 19        # j
15 05    # vload 5         # maskwidth
A1 00 06 # if_icmplt +6    # if (j < maskwidth) goto <40:body>
A7 00 93 # goto +147       # goto <41:exit>
# <40:body>
15 12    # vload 18        # i
15 13    # vload 19        # j
15 05    # vload 5         # maskwidth
15 05    # vload 5         # maskwidth
B8 00 12 # invokestatic 18 # get_index(i, j, maskwidth, maskwidth)
36 10    # vstore 16       # index_mask = get_index(i, j, maskwidth, maskwidth);
15 0A    # vload 10        # mask_first_row
15 12    # vload 18        # i
60       # iadd            # (mask_first_row + i)
15 0B    # vload 11        # mask_first_col
15 13    # vload 19        # j
60       # iadd            # (mask_first_col + j)
15 02    # vload 2         # width
15 03    # vload 3         # height
B8 00 11 # invokestatic 17 # is_valid_pixel((mask_first_row + i), (mask_first_col + j), width, height)
10 01    # bipush 1        # true
9F 00 06 # if_cmpeq +6     # if (is_valid_pixel((mask_first_row + i), (mask_first_col + j), width, height) == true) goto <42:then>
A7 00 63 # goto +99        # goto <43:else>
# <42:then>
15 0A    # vload 10        # mask_first_row
15 12    # vload 18        # i
60       # iadd            # (mask_first_row + i)
15 0B    # vload 11        # mask_first_col
15 13    # vload 19        # j
60       # iadd            # (mask_first_col + j)
15 02    # vload 2         # width
15 03    # vload 3         # height
B8 00 12 # invokestatic 18 # get_index((mask_first_row + i), (mask_first_col + j), width, height)
36 11    # vstore 17       # index_A = get_index((mask_first_row + i), (mask_first_col + j), width, height);
15 0C    # vload 12        # sum_red
15 01    # vload 1         # A
15 11    # vload 17        # index_A
63       # aadds           # &A[index_A]
2E       # imload          # A[index_A]
B8 00 01 # invokestatic 1  # get_red(A[index_A])
15 04    # vload 4         # mask
15 10    # vload 16        # index_mask
63       # aadds           # &mask[index_mask]
2E       # imload          # mask[index_mask]
68       # imul            # (get_red(A[index_A]) * mask[index_mask])
60       # iadd            # 
36 0C    # vstore 12       # sum_red += (get_red(A[index_A]) * mask[index_mask]);
15 0D    # vload 13        # sum_green
15 01    # vload 1         # A
15 11    # vload 17        # index_A
63       # aadds           # &A[index_A]
2E       # imload          # A[index_A]
B8 00 02 # invokestatic 2  # get_green(A[index_A])
15 04    # vload 4         # mask
15 10    # vload 16        # index_mask
63       # aadds           # &mask[index_mask]
2E       # imload          # mask[index_mask]
68       # imul            # (get_green(A[index_A]) * mask[index_mask])
60       # iadd            # 
36 0D    # vstore 13       # sum_green += (get_green(A[index_A]) * mask[index_mask]);
15 0E    # vload 14        # sum_blue
15 01    # vload 1         # A
15 11    # vload 17        # index_A
63       # aadds           # &A[index_A]
2E       # imload          # A[index_A]
B8 00 03 # invokestatic 3  # get_blue(A[index_A])
15 04    # vload 4         # mask
15 10    # vload 16        # index_mask
63       # aadds           # &mask[index_mask]
2E       # imload          # mask[index_mask]
68       # imul            # (get_blue(A[index_A]) * mask[index_mask])
60       # iadd            # 
36 0E    # vstore 14       # sum_blue += (get_blue(A[index_A]) * mask[index_mask]);
15 0F    # vload 15        # weight
15 04    # vload 4         # mask
15 10    # vload 16        # index_mask
63       # aadds           # &mask[index_mask]
2E       # imload          # mask[index_mask]
60       # iadd            # 
36 0F    # vstore 15       # weight += mask[index_mask];
A7 00 03 # goto +3         # goto <44:endif>
# <43:else>
# <44:endif>
15 13    # vload 19        # j
10 01    # bipush 1        # 1
60       # iadd            # 
36 13    # vstore 19       # j += 1;
A7 FF 69 # goto -151       # goto <39:loop>
# <41:exit>
15 12    # vload 18        # i
10 01    # bipush 1        # 1
60       # iadd            # 
36 12    # vstore 18       # i += 1;
A7 FF 51 # goto -175       # goto <36:loop>
# <38:exit>
15 01    # vload 1         # A
15 00    # vload 0         # index
63       # aadds           # &A[index]
2E       # imload          # A[index]
B8 00 04 # invokestatic 4  # get_alpha(A[index])
15 0C    # vload 12        # sum_red
15 0F    # vload 15        # weight
6C       # idiv            # (sum_red / weight)
15 0D    # vload 13        # sum_green
15 0F    # vload 15        # weight
6C       # idiv            # (sum_green / weight)
15 0E    # vload 14        # sum_blue
15 0F    # vload 15        # weight
6C       # idiv            # (sum_blue / weight)
B8 00 05 # invokestatic 5  # make_pixel(get_alpha(A[index]), (sum_red / weight), (sum_green / weight), (sum_blue / weight))
36 12    # vstore 18       # pixel_new = make_pixel(get_alpha(A[index]), (sum_red / weight), (sum_green / weight), (sum_blue / weight));
15 12    # vload 18        # pixel_new
B0       # return          # 


#<is_origin>
00 03             # number of arguments = 3
00 14             # number of local variables = 20
00 22             # code length = 34 bytes
15 00    # vload 0         # index
15 02    # vload 2         # maskwidth
10 02    # bipush 2        # 2
6C       # idiv            # (maskwidth / 2)
15 02    # vload 2         # maskwidth
10 02    # bipush 2        # 2
6C       # idiv            # (maskwidth / 2)
15 02    # vload 2         # maskwidth
15 02    # vload 2         # maskwidth
B8 00 12 # invokestatic 18 # get_index((maskwidth / 2), (maskwidth / 2), maskwidth, maskwidth)
9F 00 06 # if_cmpeq +6     # if (index == get_index((maskwidth / 2), (maskwidth / 2), maskwidth, maskwidth)) goto <45:then>
A7 00 09 # goto +9         # goto <46:else>
# <45:then>
10 01    # bipush 1        # true
B0       # return          # 
A7 00 03 # goto +3         # goto <47:endif>
# <46:else>
# <47:endif>
10 00    # bipush 0        # false
B0       # return          # 


#<is_weight_valid>
00 03             # number of arguments = 3
00 14             # number of local variables = 20
00 36             # code length = 54 bytes
15 01    # vload 1         # mask
15 00    # vload 0         # index
63       # aadds           # &mask[index]
2E       # imload          # mask[index]
10 00    # bipush 0        # 0
A1 00 25 # if_icmplt +37   # if (mask[index] < 0) goto <48:then>
A7 00 03 # goto +3         # goto <51:or>
# <51:or>
15 00    # vload 0         # index
15 01    # vload 1         # mask
15 02    # vload 2         # maskwidth
B8 00 14 # invokestatic 20 # is_origin(index, mask, maskwidth)
10 01    # bipush 1        # true
9F 00 06 # if_cmpeq +6     # if (is_origin(index, mask, maskwidth) == true) goto <52:and>
A7 00 17 # goto +23        # goto <49:else>
# <52:and>
15 01    # vload 1         # mask
15 00    # vload 0         # index
63       # aadds           # &mask[index]
2E       # imload          # mask[index]
10 00    # bipush 0        # 0
9F 00 06 # if_cmpeq +6     # if (mask[index] == 0) goto <48:then>
A7 00 09 # goto +9         # goto <49:else>
# <48:then>
10 00    # bipush 0        # false
B0       # return          # 
A7 00 03 # goto +3         # goto <50:endif>
# <49:else>
# <50:endif>
10 01    # bipush 1        # true
B0       # return          # 


#<is_mask_valid>
00 02             # number of arguments = 2
00 14             # number of local variables = 20
00 35             # code length = 53 bytes
10 00    # bipush 0        # 0
36 02    # vstore 2        # i = 0;
# <53:loop>
15 02    # vload 2         # i
15 01    # vload 1         # maskwidth
15 01    # vload 1         # maskwidth
68       # imul            # (maskwidth * maskwidth)
A1 00 06 # if_icmplt +6    # if (i < (maskwidth * maskwidth)) goto <54:body>
A7 00 24 # goto +36        # goto <55:exit>
# <54:body>
15 02    # vload 2         # i
15 00    # vload 0         # mask
15 01    # vload 1         # maskwidth
B8 00 15 # invokestatic 21 # is_weight_valid(i, mask, maskwidth)
10 01    # bipush 1        # true
9F 00 0C # if_cmpeq +12    # if (is_weight_valid(i, mask, maskwidth) == true) goto <57:else>
A7 00 03 # goto +3         # goto <56:then>
# <56:then>
10 00    # bipush 0        # false
B0       # return          # 
A7 00 03 # goto +3         # goto <58:endif>
# <57:else>
# <58:endif>
15 02    # vload 2         # i
10 01    # bipush 1        # 1
60       # iadd            # 
36 02    # vstore 2        # i += 1;
A7 FF D5 # goto -43        # goto <53:loop>
# <55:exit>
10 01    # bipush 1        # true
B0       # return          # 


#<blur>
00 05             # number of arguments = 5
00 07             # number of local variables = 7
00 3C             # code length = 60 bytes
15 01    # vload 1         # width
15 02    # vload 2         # height
68       # imul            # (width * height)
BC 04    # newarray 4      # alloc_array(pixel_t, (width * height))
36 05    # vstore 5        # B = alloc_array(pixel_t, (width * height));
10 00    # bipush 0        # 0
36 06    # vstore 6        # i = 0;
# <33:loop>
15 06    # vload 6         # i
15 01    # vload 1         # width
15 02    # vload 2         # height
68       # imul            # (width * height)
A1 00 06 # if_icmplt +6    # if (i < (width * height)) goto <34:body>
A7 00 22 # goto +34        # goto <35:exit>
# <34:body>
15 05    # vload 5         # B
15 06    # vload 6         # i
63       # aadds           # &B[i]
15 06    # vload 6         # i
15 00    # vload 0         # A
15 01    # vload 1         # width
15 02    # vload 2         # height
15 03    # vload 3         # mask
15 04    # vload 4         # maskwidth
B8 00 13 # invokestatic 19 # blur_each(i, A, width, height, mask, maskwidth)
4E       # imstore         # B[i] = blur_each(i, A, width, height, mask, maskwidth);
15 06    # vload 6         # i
10 01    # bipush 1        # 1
60       # iadd            # 
36 06    # vstore 6        # i += 1;
A7 FF D7 # goto -41        # goto <33:loop>
# <35:exit>
15 05    # vload 5         # B
B0       # return          # 


#<blur_main>
00 03             # number of arguments = 3
00 14             # number of local variables = 20
02 0E             # code length = 526 bytes
14 00 00 # aldc 0          # s[0] = "Input image file:  "
B7 00 03 # invokenative 3  # print("Input image file:  ")
57       # pop             # (ignore result)
15 00    # vload 0         # input
B7 00 04 # invokenative 4  # println(input)
57       # pop             # (ignore result)
14 00 14 # aldc 20         # s[20] = "Output image file: "
B7 00 03 # invokenative 3  # print("Output image file: ")
57       # pop             # (ignore result)
15 01    # vload 1         # output
B7 00 04 # invokenative 4  # println(output)
57       # pop             # (ignore result)
14 00 28 # aldc 40         # s[40] = "Blur mask file: "
B7 00 03 # invokenative 3  # print("Blur mask file: ")
57       # pop             # (ignore result)
15 02    # vload 2         # mask
B7 00 04 # invokenative 4  # println(mask)
57       # pop             # (ignore result)
14 00 39 # aldc 57         # s[57] = ""
B7 00 04 # invokenative 4  # println("")
57       # pop             # (ignore result)
15 00    # vload 0         # input
B7 00 05 # invokenative 5  # image_load(input)
36 03    # vstore 3        # source = image_load(input);
15 03    # vload 3         # source
01       # aconst_null     # NULL
9F 00 06 # if_cmpeq +6     # if (source == NULL) goto <59:then>
A7 00 0A # goto +10        # goto <60:else>
# <59:then>
14 00 3A # aldc 58         # s[58] = "Could not load source image"
BF       # athrow          # error "Could not load source image"
A7 00 03 # goto +3         # goto <61:endif>
# <60:else>
# <61:endif>
15 03    # vload 3         # source
B7 00 06 # invokenative 6  # image_width(source)
36 04    # vstore 4        # width = image_width(source);
15 03    # vload 3         # source
B7 00 07 # invokenative 7  # image_height(source)
36 05    # vstore 5        # height = image_height(source);
15 03    # vload 3         # source
B7 00 08 # invokenative 8  # image_data(source)
36 06    # vstore 6        # inpixels = image_data(source);
14 00 56 # aldc 86         # s[86] = "Loaded image.  Dimensions are "
B7 00 03 # invokenative 3  # print("Loaded image.  Dimensions are ")
57       # pop             # (ignore result)
15 04    # vload 4         # width
B7 00 09 # invokenative 9  # printint(width)
57       # pop             # (ignore result)
14 00 75 # aldc 117        # s[117] = " by "
B7 00 03 # invokenative 3  # print(" by ")
57       # pop             # (ignore result)
15 05    # vload 5         # height
B7 00 09 # invokenative 9  # printint(height)
57       # pop             # (ignore result)
14 00 7A # aldc 122        # s[122] = "."
B7 00 04 # invokenative 4  # println(".")
57       # pop             # (ignore result)
15 02    # vload 2         # mask
B7 00 0A # invokenative 10 # file_read(mask)
36 07    # vstore 7        # file = file_read(mask);
15 07    # vload 7         # file
B7 00 0C # invokenative 12 # file_readline(file)
10 0A    # bipush 10       # 10
B7 00 0B # invokenative 11 # parse_int(file_readline(file), 10)
36 08    # vstore 8        # size_ptr = parse_int(file_readline(file), 10);
15 08    # vload 8         # size_ptr
01       # aconst_null     # NULL
9F 00 06 # if_cmpeq +6     # if (size_ptr == NULL) goto <62:then>
A7 00 0A # goto +10        # goto <63:else>
# <62:then>
14 00 7C # aldc 124        # s[124] = "Invalid blur mask size"
BF       # athrow          # error "Invalid blur mask size"
A7 00 03 # goto +3         # goto <64:endif>
# <63:else>
# <64:endif>
15 08    # vload 8         # size_ptr
2E       # imload          # *(size_ptr)
36 09    # vstore 9        # size = *(size_ptr);
15 09    # vload 9         # size
10 00    # bipush 0        # 0
A1 00 20 # if_icmplt +32   # if (size < 0) goto <65:then>
A7 00 03 # goto +3         # goto <69:or>
# <69:or>
15 09    # vload 9         # size
10 02    # bipush 2        # 2
70       # irem            # (size % 2)
10 01    # bipush 1        # 1
A0 00 13 # if_cmpne +19    # if ((size % 2) != 1) goto <65:then>
A7 00 03 # goto +3         # goto <68:or>
# <68:or>
15 09    # vload 9         # size
15 09    # vload 9         # size
15 09    # vload 9         # size
68       # imul            # (size * size)
A3 00 06 # if_icmpgt +6    # if (size > (size * size)) goto <65:then>
A7 00 0A # goto +10        # goto <66:else>
# <65:then>
14 00 93 # aldc 147        # s[147] = "Invalid blur mask size"
BF       # athrow          # error "Invalid blur mask size"
A7 00 03 # goto +3         # goto <67:endif>
# <66:else>
# <67:endif>
15 09    # vload 9         # size
B7 00 09 # invokenative 9  # printint(size)
57       # pop             # (ignore result)
14 00 AA # aldc 170        # s[170] = ""
B7 00 04 # invokenative 4  # println("")
57       # pop             # (ignore result)
15 09    # vload 9         # size
15 09    # vload 9         # size
68       # imul            # (size * size)
BC 04    # newarray 4      # alloc_array(int, (size * size))
36 0A    # vstore 10       # blurmask = alloc_array(int, (size * size));
10 00    # bipush 0        # 0
36 0B    # vstore 11       # i = 0;
15 09    # vload 9         # size
15 09    # vload 9         # size
68       # imul            # (size * size)
36 0C    # vstore 12       # limit = (size * size);
# <70:loop>
15 07    # vload 7         # file
B7 00 0D # invokenative 13 # file_eof(file)
10 01    # bipush 1        # true
9F 00 5A # if_cmpeq +90    # if (file_eof(file) == true) goto <72:exit>
A7 00 03 # goto +3         # goto <73:and>
# <73:and>
15 0B    # vload 11        # i
15 0C    # vload 12        # limit
A1 00 06 # if_icmplt +6    # if (i < limit) goto <71:body>
A7 00 4D # goto +77        # goto <72:exit>
# <71:body>
15 07    # vload 7         # file
B7 00 0C # invokenative 12 # file_readline(file)
10 0A    # bipush 10       # 10
B7 00 0B # invokenative 11 # parse_int(file_readline(file), 10)
36 0D    # vstore 13       # value = parse_int(file_readline(file), 10);
15 0D    # vload 13        # value
01       # aconst_null     # NULL
9F 00 11 # if_cmpeq +17    # if (value == NULL) goto <74:then>
A7 00 03 # goto +3         # goto <77:or>
# <77:or>
15 0D    # vload 13        # value
2E       # imload          # *(value)
10 00    # bipush 0        # 0
A1 00 06 # if_icmplt +6    # if (*(value) < 0) goto <74:then>
A7 00 1A # goto +26        # goto <75:else>
# <74:then>
14 00 AB # aldc 171        # s[171] = "Line "
B7 00 03 # invokenative 3  # print("Line ")
57       # pop             # (ignore result)
15 0B    # vload 11        # i
10 02    # bipush 2        # 2
60       # iadd            # (i + 2)
B7 00 09 # invokenative 9  # printint((i + 2))
57       # pop             # (ignore result)
14 00 B1 # aldc 177        # s[177] = " has invalid weight"
BF       # athrow          # error " has invalid weight"
A7 00 03 # goto +3         # goto <76:endif>
# <75:else>
# <76:endif>
15 0A    # vload 10        # blurmask
15 0B    # vload 11        # i
63       # aadds           # &blurmask[i]
15 0D    # vload 13        # value
2E       # imload          # *(value)
4E       # imstore         # blurmask[i] = *(value);
15 0B    # vload 11        # i
10 01    # bipush 1        # 1
60       # iadd            # 
36 0B    # vstore 11       # i += 1;
A7 FF A2 # goto -94        # goto <70:loop>
# <72:exit>
15 0B    # vload 11        # i
15 0C    # vload 12        # limit
A0 00 06 # if_cmpne +6     # if (i != limit) goto <78:then>
A7 00 0A # goto +10        # goto <79:else>
# <78:then>
14 00 C5 # aldc 197        # s[197] = "Not enough weights in mask file"
BF       # athrow          # error "Not enough weights in mask file"
A7 00 03 # goto +3         # goto <80:endif>
# <79:else>
# <80:endif>
15 07    # vload 7         # file
B7 00 0D # invokenative 13 # file_eof(file)
10 01    # bipush 1        # true
9F 00 10 # if_cmpeq +16    # if (file_eof(file) == true) goto <82:else>
A7 00 03 # goto +3         # goto <81:then>
# <81:then>
14 00 E5 # aldc 229        # s[229] = "Warning: ignoring extra values in mask file!\n"
B7 00 03 # invokenative 3  # print("Warning: ignoring extra values in mask file!\n")
57       # pop             # (ignore result)
A7 00 03 # goto +3         # goto <83:endif>
# <82:else>
# <83:endif>
15 0A    # vload 10        # blurmask
15 09    # vload 9         # size
10 02    # bipush 2        # 2
6C       # idiv            # (size / 2)
15 09    # vload 9         # size
68       # imul            # ((size / 2) * size)
15 09    # vload 9         # size
10 02    # bipush 2        # 2
6C       # idiv            # (size / 2)
60       # iadd            # (((size / 2) * size) + (size / 2))
63       # aadds           # &blurmask[(((size / 2) * size) + (size / 2))]
2E       # imload          # blurmask[(((size / 2) * size) + (size / 2))]
10 00    # bipush 0        # 0
9F 00 06 # if_cmpeq +6     # if (blurmask[(((size / 2) * size) + (size / 2))] == 0) goto <84:then>
A7 00 0A # goto +10        # goto <85:else>
# <84:then>
14 01 13 # aldc 275        # s[275] = "Origin of mask has value 0"
BF       # athrow          # error "Origin of mask has value 0"
A7 00 03 # goto +3         # goto <86:endif>
# <85:else>
# <86:endif>
14 01 2E # aldc 302        # s[302] = "Running blur..."
B7 00 03 # invokenative 3  # print("Running blur...")
57       # pop             # (ignore result)
B7 00 0E # invokenative 14 # flush()
57       # pop             # (ignore result)
15 06    # vload 6         # inpixels
15 04    # vload 4         # width
15 05    # vload 5         # height
15 0A    # vload 10        # blurmask
15 09    # vload 9         # size
B8 00 17 # invokestatic 23 # blur(inpixels, width, height, blurmask, size)
36 0D    # vstore 13       # resultpixels = blur(inpixels, width, height, blurmask, size);
14 01 3E # aldc 318        # s[318] = "done."
B7 00 04 # invokenative 4  # println("done.")
57       # pop             # (ignore result)
15 04    # vload 4         # width
15 05    # vload 5         # height
B7 00 0F # invokenative 15 # image_create(width, height)
36 0E    # vstore 14       # dest = image_create(width, height);
15 0E    # vload 14        # dest
B7 00 08 # invokenative 8  # image_data(dest)
36 0F    # vstore 15       # outpixels = image_data(dest);
10 00    # bipush 0        # 0
36 0B    # vstore 11       # i = 0;
# <87:loop>
15 0B    # vload 11        # i
15 04    # vload 4         # width
15 05    # vload 5         # height
68       # imul            # (width * height)
A1 00 06 # if_icmplt +6    # if (i < (width * height)) goto <88:body>
A7 00 19 # goto +25        # goto <89:exit>
# <88:body>
15 0F    # vload 15        # outpixels
15 0B    # vload 11        # i
63       # aadds           # &outpixels[i]
15 0D    # vload 13        # resultpixels
15 0B    # vload 11        # i
63       # aadds           # &resultpixels[i]
2E       # imload          # resultpixels[i]
4E       # imstore         # outpixels[i] = resultpixels[i];
15 0B    # vload 11        # i
10 01    # bipush 1        # 1
60       # iadd            # 
36 0B    # vstore 11       # i += 1;
A7 FF E0 # goto -32        # goto <87:loop>
# <89:exit>
14 01 44 # aldc 324        # s[324] = "Saving output..."
B7 00 03 # invokenative 3  # print("Saving output...")
57       # pop             # (ignore result)
B7 00 0E # invokenative 14 # flush()
57       # pop             # (ignore result)
15 0E    # vload 14        # dest
15 01    # vload 1         # output
B7 00 10 # invokenative 16 # image_save(dest, output)
57       # pop             # (ignore result)
14 01 55 # aldc 341        # s[341] = "done."
B7 00 04 # invokenative 4  # println("done.")
57       # pop             # (ignore result)
10 00    # bipush 0        # dummy return value
B0       # return          # 


#<default_output>
00 02             # number of arguments = 2
00 14             # number of local variables = 20
00 60             # code length = 96 bytes
15 00    # vload 0         # input
B7 00 11 # invokenative 17 # string_length(input)
36 02    # vstore 2        # len = string_length(input);
15 02    # vload 2         # len
10 04    # bipush 4        # 4
A3 00 06 # if_icmpgt +6    # if (len > 4) goto <93:and>
A7 00 1D # goto +29        # goto <90:then>
# <93:and>
14 01 5B # aldc 347        # s[347] = ".png"
15 00    # vload 0         # input
15 02    # vload 2         # len
10 04    # bipush 4        # 4
64       # isub            # (len - 4)
15 02    # vload 2         # len
B7 00 13 # invokenative 19 # string_sub(input, (len - 4), len)
B7 00 12 # invokenative 18 # string_equal(".png", string_sub(input, (len - 4), len))
10 01    # bipush 1        # true
9F 00 0D # if_cmpeq +13    # if (string_equal(".png", string_sub(input, (len - 4), len)) == true) goto <91:else>
A7 00 03 # goto +3         # goto <90:then>
# <90:then>
14 01 60 # aldc 352        # s[352] = "Input file does not end with .png"
BF       # athrow          # error "Input file does not end with .png"
A7 00 03 # goto +3         # goto <92:endif>
# <91:else>
# <92:endif>
15 00    # vload 0         # input
10 00    # bipush 0        # 0
15 02    # vload 2         # len
10 04    # bipush 4        # 4
64       # isub            # (len - 4)
B7 00 13 # invokenative 19 # string_sub(input, 0, (len - 4))
36 03    # vstore 3        # res = string_sub(input, 0, (len - 4));
15 03    # vload 3         # res
14 01 82 # aldc 386        # s[386] = "_"
B7 00 14 # invokenative 20 # string_join(res, "_")
36 03    # vstore 3        # res = string_join(res, "_");
15 03    # vload 3         # res
15 01    # vload 1         # name
B7 00 14 # invokenative 20 # string_join(res, name)
36 03    # vstore 3        # res = string_join(res, name);
15 03    # vload 3         # res
14 01 84 # aldc 388        # s[388] = ".png"
B7 00 14 # invokenative 20 # string_join(res, ".png")
36 03    # vstore 3        # res = string_join(res, ".png");
15 03    # vload 3         # res
B0       # return          # 

00 17             # native count
# native pool
00 01 00 5B       # char_chr
00 01 00 5C       # char_ord
00 01 00 60       # string_from_chararray
00 01 00 06       # print
00 01 00 0A       # println
00 01 00 51       # image_load
00 01 00 54       # image_width
00 01 00 50       # image_height
00 01 00 4F       # image_data
00 01 00 09       # printint
00 01 00 41       # file_read
00 02 00 58       # parse_int
00 01 00 42       # file_readline
00 01 00 40       # file_eof
00 00 00 05       # flush
00 02 00 4E       # image_create
00 02 00 52       # image_save
00 01 00 65       # string_length
00 02 00 5F       # string_equal
00 03 00 66       # string_sub
00 02 00 64       # string_join
00 02 00 03       # args_string
00 00 00 02       # args_parse

